#!/usr/bin/python
import sys
import os
import StringIO
import time
import codecs
import smtplib
import traceback
from argparse import ArgumentParser
import imaplib
import email
import re
import cgi
import cfgreader

# Read in custom configurations
g_cfg = cfgreader.CfgReader(__file__.replace('.py', '.cfg'))

# These two strings will form the header and individual
# items of the RSS feed.
feed_header = """<?xml version="1.0" encoding="iso-8859-1"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>DVDs shipped for %s</title>
<link>http://dvd.netflix.com/Queue</link>
<atom:link href="http://%s/%s.xml" rel="self" type="application/rss+xml" />
<pubDate>%%s</pubDate>
<description>Feed automatically generated by %s</description>
<language>en-us</language>
""" % (g_cfg.main.name, g_cfg.main.url_base,
       g_cfg.main.rss_base, g_cfg.main.url_base)

feed_item = """<item>
<title>%s</title>
<pubDate>%s</pubDate>
<link>%s</link>
<guid isPermaLink="false">%s</guid>
<description>The disc &lt;a href="%s"&gt;%s&lt;/a&gt; was shipped on %s.</description>
</item>
"""


def send_email(subject, msg, toaddrs,
               fromaddr='"%s" <%s>' % (os.path.basename(__file__),
                                       g_cfg.smtp.from_addr)):
    """ Sends Email
    This function is only used in an emergency.
    """
    smtp = smtplib.SMTP('localhost')
    smtp.login(g_cfg.smtp.user, g_cfg.smtp.password)
    smtp.sendmail(fromaddr, toaddrs,
                  "Content-Type: text/plain; charset=\"us-ascii\"\r\n"
                  "From: %s\r\nTo: %s\r\nSubject: %s\r\n%s" %
                  (fromaddr, ", ".join(toaddrs), subject, msg))
    smtp.quit()


def write_feed(script_dir, feed_items):
    """ Given a list of feed_items, write an FSS feed. """
    now = time.strftime("%a, %d %b %Y %H:%M:%S +0000", time.gmtime())
    index = 0
    do_move = False
    temp_fname = os.path.join(script_dir, g_cfg.main.rss_base + '.temp.xml')
    dest_fname = os.path.join(script_dir, g_cfg.main.rss_base + '.xml')
    with open(temp_fname, 'wb') as f:
        f.write(feed_header % (now,))
        for title, url, ship_date in reversed(feed_items):
            title = cgi.escape(title)
            guid = "%s+%s+%d" % (url, now, index)
            f.write(feed_item % (title,
                                 ship_date,
                                 url,
                                 guid,
                                 url, title, ship_date[:-15]))
            index += 1
        f.write('</channel></rss>')
        do_move = True
    if do_move:
        os.rename(temp_fname, dest_fname)
        return "OK (Wrote %d new item%s.)" % \
               (len(feed_items), len(feed_items) > 1 and "s" or "")
    return "Could not update the feed file."


def get_url_from_message(part):
    """ Given a part of an email message, try to find the NetFlix URL within.  """
    urlpat = re.compile('http://dvd.netflix.com/Movie/\d+')
    txt = str(part)
    matches = urlpat.search(txt)
    if matches is None:
        return "NO", "The body no longer has the same type of URL."
    return "OK", matches.group(0)


def main(script_dir):
    """ Fetch all the mail, and try to find messages that
    match a pattern like, "For Wed: Some Movie".

    It'll add those movies to the RSS feed, and if that's
    completed successfully, then it'll delete the processed email.
    """
    server = imaplib.IMAP4(g_cfg.imap.mailbox)
    server.login(g_cfg.imap.user, g_cfg.imap.password)
    server.select()
    status, data = server.search(None, 'ALL')
    if status != 'OK':
        raise Exception('Getting the list of messages resulted in %s' % status)

    messages_to_delete = []
    feed_items = []
    for num in data[0].split():
        status, data = server.fetch(num, '(RFC822)')
        if status != 'OK':
            raise Exception('Fetching message %s resulted in %s' % (num, status))
        msg = email.message_from_string(data[0][1])
        subject = msg['Subject']

        if subject.startswith('Fwd: '):
            subject = subject[5:]

        if subject.startswith("We've received: ") or \
           subject.startswith("Shipping today!"):
            # We will bypass, but delete this message as recognized
            # print "Bypassing message", num, subject
            messages_to_delete.append(num)
            continue

        dvd_title = ""
        if subject.startswith("For ") and subject.find(':') != -1:
            # Strip off the "For Xxx:". DVD title follows.
            dvd_title = subject.split(':', 1)[1].strip()
        elif subject.startswith("We sent you "):
            # Strip off "We sent you". DVD title is next.
            dvd_title = subject[12:]
        else:
            print 'Subject "%s" was unexpected, but the script is continuing. ' \
                  'Please take a look at the mailbox.' % subject
            continue

        got_url = False
        url = ""
        for part in msg.walk():
            content_type = part.get_content_type()
            if content_type == "text/plain" or content_type == "text/html":
                # Now find the URL near the "Shipped" line.
                status, url = get_url_from_message(part)
                if status == 'OK':
                    got_url = True
                    break

        if not got_url:
            raise Exception(url)

        messages_to_delete.append(num)
        # Append the disc name and movie URL to a list of items
        feed_items.append((dvd_title, url, msg['Date']))

    # Ensure the new feed is written
    update_status = "OK"
    if len(feed_items) > 0:
        update_status = write_feed(script_dir, feed_items)

    if update_status.startswith("OK"):
        # Now delete only the messages marked for deletion
        for num in messages_to_delete:
            server.store(num, '+FLAGS', '\\Deleted')
        server.expunge()

    server.close()
    server.logout()
    print update_status
    return update_status


if __name__ == '__main__':
    # Everything here and below is boiler-plate for cron jobs.
    script_dir = os.path.abspath(os.path.dirname(sys.argv[0]))
    parser = ArgumentParser(description="cronjob to create Netflix DVD feed.")
    parser.add_argument('-d', '--debug', action='store_true')
    args = parser.parse_args()

    start_time = time.time()
    if args.debug:
        message = main(script_dir)
    else:
        old_stdout = sys.stdout
        old_stderr = sys.stderr
        sys.stdout = sys.stderr = StringIO.StringIO()
        try:
            main(script_dir)
        except Exception, e:
            exceptional_text = "Exception: " + str(e.__class__) + " " + str(e)
            print exceptional_text
            traceback.print_exc(file=sys.stdout)
            try:
                send_email('Exception thrown in %s' % (os.path.basename(__file__),),
                           exceptional_text + "\n" + traceback.format_exc(),
                           (g_cfg.smtp.to,))
            except Exception, e:
                traceback.print_exc(file=sys.stdout)
                print "Could not send email to notify you of the exception. :("

        message = sys.stdout.getvalue()
        sys.stdout = old_stdout
        sys.stderr = old_stderr

    # Finally, let's save this to a statistics page
    if os.path.exists(os.path.join(script_dir, g_cfg.main.logfile)):
        with codecs.open(os.path.join(script_dir, g_cfg.main.logfile), 'r', 'utf-8') as f:
            lines = f.readlines()
    else:
        lines = []
    lines = lines[:168]  # Just keep some recent lines
    status = u'\n                       '.join(message.decode('utf-8').splitlines())
    lines.insert(0, u"%s %3.0fs %s\n" % (time.strftime('%Y-%m-%d, %H:%M', time.localtime()),
                                         time.time() - start_time,
                                         status))
    with codecs.open(os.path.join(script_dir, g_cfg.main.logfile), 'w', 'utf-8') as f:
        f.writelines(lines)
